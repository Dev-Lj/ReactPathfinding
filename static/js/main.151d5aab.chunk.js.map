{"version":3,"sources":["pathfinding/GridVisualization/NodeVisual.jsx","pathfinding/PathFinder/Node.js","pathfinding/GridVisualization/Grid.jsx","pathfinding/PathFinder/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["CLICKMODE","NODEMODE","NodeVisual","this","props","coordinates","className","mode","onClick","nodeClicked","onMouseOver","e","buttons","React","Component","Node","xPos","yPos","Infinity","distance","lastNode","sleep","ms","Promise","resolve","setTimeout","Grid","state","nodesGrid","isPathfindingRunning","nodeClickMode","grid","createRef","bind","initGrid","screenTiltEvent","window","addEventListener","removeEventListener","afterOrientationChanged","gridProperties","calculateGridProportions","amountX","amountY","y","x","key","Y","X","createNodesVisualGrid","Width","Height","isValidNode","startNode","getNode","setStartNode","undefined","targetNode","setTargetNode","oldWallNodes","forEach","node","wallNode","setWallNode","setState","doableWidth","Math","floor","current","offsetWidth","doableHeight","innerHeight","offsetTop","clickedNode","getCoordinates","isWallNode","alert","indexOf","push","splice","pathFinder","init","visualGridToNodesGrid","doPathFinding","visitedNodes","shortestPath","visualizePathFinding","visualizeShortestPath","entries","row","visualNode","setDistanceToStartNode","setIsWall","console","error","getYPos","getXPos","map","type","startPathFinding","disabled","ref","formatNodes","PathFinder","gridToUnvisited","unvisitedNodes","Error","length","sortByDistance","currentNode","shift","isWall","isTargetNode","getShortestPath","getDistanceToStartNode","neighbours","getUnvisitedNeighbours","updateNeighbours","setVisited","getLastNode","filter","nodeXPos","nodeYPos","isVisited","distanceOfNeighbour","neighbour","setLastNode","nodes","sort","a","b","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.151d5aab.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./NodeVisual.css\";\r\n\r\nexport const CLICKMODE = {\r\n  START: \"start\",\r\n  TARGET: \"target\",\r\n  WALL: \"wall\",\r\n};\r\n\r\nexport const NODEMODE = {\r\n  NONE: \"\",\r\n  START: \"start\",\r\n  TARGET: \"target\",\r\n  WALL: \"wall\",\r\n  WAY: \"way\",\r\n  VISITED: \"visited\",\r\n};\r\n\r\nexport class NodeVisual extends React.Component {\r\n  getCoordinates() {\r\n    return this.props.coordinates;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        className={\"node border \" + this.props.mode}\r\n        onClick={() => {\r\n          if (this.props.nodeClicked) {\r\n            this.props.nodeClicked(this);\r\n          }\r\n        }}\r\n        onMouseOver={(e) => {\r\n          if (e.buttons === 1) {\r\n            this.props.nodeClicked(this);\r\n          }\r\n        }}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default NodeVisual;\r\n","class Node {\r\n  #xPos;\r\n  #yPos;\r\n  #distanceToStartNode = Infinity;\r\n  #lastNode;\r\n  #isVisited = false;\r\n  #isTargetNode = false;\r\n  #isWall = false;\r\n\r\n  constructor(xPos, yPos) {\r\n    this.#xPos = xPos;\r\n    this.#yPos = yPos;\r\n  }\r\n\r\n  setDistanceToStartNode(distance) {\r\n    this.#distanceToStartNode = distance;\r\n  }\r\n\r\n  getDistanceToStartNode() {\r\n    return this.#distanceToStartNode;\r\n  }\r\n\r\n  setTargetNode() {\r\n    this.#isTargetNode = true;\r\n  }\r\n\r\n  isTargetNode() {\r\n    return this.#isTargetNode;\r\n  }\r\n\r\n  setIsWall() {\r\n    this.#isWall = true;\r\n  }\r\n\r\n  isWall() {\r\n    return this.#isWall;\r\n  }\r\n\r\n  setVisited() {\r\n    this.#isVisited = true;\r\n  }\r\n\r\n  isVisited() {\r\n    return this.#isVisited;\r\n  }\r\n\r\n  getXPos() {\r\n    return this.#xPos;\r\n  }\r\n\r\n  getYPos() {\r\n    return this.#yPos;\r\n  }\r\n\r\n  setLastNode(lastNode) {\r\n    this.#lastNode = lastNode;\r\n  }\r\n\r\n  getLastNode() {\r\n    return this.#lastNode;\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","import { NodeVisual, CLICKMODE, NODEMODE } from \"./NodeVisual\";\r\nimport Node from \"../PathFinder/Node\";\r\nimport React from \"react\";\r\n\r\nconst NODE_AMOUNT_X = 60;\r\nconst NODE_AMOUNT_Y = 60;\r\n\r\nclass Grid extends React.Component {\r\n  #startNode;\r\n  #targetNode;\r\n  #wallNodes = [];\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodesGrid: [],\r\n      isPathfindingRunning: false,\r\n      nodeClickMode: CLICKMODE.START,\r\n    };\r\n    this.grid = React.createRef();\r\n    this.nodeClicked = this.nodeClicked.bind(this);\r\n    this.initGrid = this.initGrid.bind(this);\r\n    this.screenTiltEvent = this.screenTiltEvent.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.initGrid();\r\n    window.addEventListener(\"orientationchange\", this.screenTiltEvent);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.removeEventListener(\"orientationchange\", this.screenTiltEvent);\r\n  }\r\n\r\n  /**\r\n   * Init Grid AFTER resize happened\r\n   */\r\n  screenTiltEvent() {\r\n    var afterOrientationChanged = () => {\r\n      this.initGrid();\r\n      window.removeEventListener(\"resize\", afterOrientationChanged);\r\n    };\r\n    window.addEventListener(\"resize\", afterOrientationChanged);\r\n  }\r\n\r\n  initGrid() {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n    var gridProperties = this.calculateGridProportions();\r\n    const nodesGrid = createNodesVisualGrid(\r\n      gridProperties.Width,\r\n      gridProperties.Height\r\n    );\r\n    if (this.isValidNode(this.#startNode, gridProperties)) {\r\n      let startNode = this.getNode(nodesGrid, this.#startNode.coordinates);\r\n      this.setStartNode(startNode);\r\n    } else {\r\n      this.#startNode = undefined;\r\n    }\r\n    if (this.isValidNode(this.#targetNode, gridProperties)) {\r\n      let targetNode = this.getNode(nodesGrid, this.#targetNode.coordinates);\r\n      this.setTargetNode(targetNode);\r\n    } else {\r\n      this.#targetNode = undefined;\r\n    }\r\n    let oldWallNodes = [...this.#wallNodes];\r\n    this.#wallNodes = [];\r\n    oldWallNodes.forEach((node) => {\r\n      if (this.isValidNode(node, gridProperties)) {\r\n        let wallNode = this.getNode(nodesGrid, node.coordinates);\r\n        this.setWallNode(wallNode, true);\r\n      }\r\n    });\r\n    this.setState({\r\n      nodesGrid,\r\n    });\r\n  }\r\n\r\n  isValidNode(node, gridProperties) {\r\n    return (\r\n      node &&\r\n      node.coordinates.X < gridProperties.Width &&\r\n      node.coordinates.Y < gridProperties.Height\r\n    );\r\n  }\r\n\r\n  calculateGridProportions() {\r\n    let doableWidth = Math.floor(this.grid.current.offsetWidth / 15) - 2;\r\n    let doableHeight =\r\n      Math.floor((window.innerHeight - this.grid.current.offsetTop) / 15) - 2;\r\n    return {\r\n      Width: doableWidth < NODE_AMOUNT_X ? doableWidth : NODE_AMOUNT_X,\r\n      Height: doableHeight < NODE_AMOUNT_Y ? doableHeight : NODE_AMOUNT_Y,\r\n    };\r\n  }\r\n\r\n  nodeClicked(node) {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n\r\n    let clickedNode = this.getNode(this.state.nodesGrid, node.getCoordinates());\r\n\r\n    switch (this.state.nodeClickMode) {\r\n      case CLICKMODE.START:\r\n        this.setStartNode(clickedNode);\r\n        this.setState({ nodeClickMode: CLICKMODE.TARGET });\r\n        break;\r\n      case CLICKMODE.TARGET:\r\n        this.setTargetNode(clickedNode);\r\n        this.setState({ nodeClickMode: CLICKMODE.WALL });\r\n        break;\r\n      case CLICKMODE.WALL:\r\n        this.setWallNode(clickedNode, !clickedNode.isWallNode);\r\n        break;\r\n      default:\r\n        alert(`Invalid clickmode: ${this.state.nodeClickMode}`);\r\n    }\r\n    this.setState({ nodesGrid: [...this.state.nodesGrid] });\r\n  }\r\n\r\n  setStartNode(clickedNode) {\r\n    if (this.#startNode) {\r\n      this.#startNode.mode = NODEMODE.NONE;\r\n    }\r\n    clickedNode.mode = NODEMODE.START;\r\n    this.#startNode = clickedNode;\r\n  }\r\n\r\n  setTargetNode(clickedNode) {\r\n    if (this.#targetNode) {\r\n      this.#targetNode.mode = NODEMODE.NONE;\r\n    }\r\n    clickedNode.mode = NODEMODE.TARGET;\r\n    this.#targetNode = clickedNode;\r\n  }\r\n\r\n  setWallNode(clickedNode, isWallNode) {\r\n    clickedNode.mode = isWallNode ? NODEMODE.WALL : NODEMODE.NONE;\r\n    if (isWallNode && this.#wallNodes.indexOf(clickedNode) === -1) {\r\n      this.#wallNodes.push(clickedNode);\r\n    } else if (!isWallNode && this.#wallNodes.indexOf(clickedNode) !== -1) {\r\n      this.#wallNodes.splice(this.#wallNodes.indexOf(clickedNode), 1);\r\n    }\r\n  }\r\n\r\n  getNode(grid, coordinates) {\r\n    return grid[coordinates.Y][coordinates.X];\r\n  }\r\n\r\n  async startPathFinding() {\r\n    if (this.#startNode === undefined || this.#targetNode === undefined) {\r\n      alert(\"Start- or targetnode missing. Cannot start Dijkstra\");\r\n      return false;\r\n    }\r\n    this.setState({ isPathfindingRunning: true });\r\n    this.props.pathFinder.init(this.visualGridToNodesGrid());\r\n    let { visitedNodes, shortestPath } = this.props.pathFinder.doPathFinding();\r\n    await this.visualizePathFinding(visitedNodes);\r\n    await this.visualizeShortestPath(shortestPath);\r\n    await sleep(1000);\r\n    this.setState({ isPathfindingRunning: false });\r\n    this.initGrid();\r\n  }\r\n\r\n  /**\r\n   * Convert visual node objects to node objects for pathfinder to use\r\n   */\r\n  visualGridToNodesGrid() {\r\n    var nodesGrid = [];\r\n    for (let [y, row] of this.state.nodesGrid.entries()) {\r\n      nodesGrid.push([]);\r\n      for (let visualNode of row) {\r\n        let node = new Node(visualNode.coordinates.X, visualNode.coordinates.Y);\r\n        if (visualNode.mode !== NODEMODE.NONE) {\r\n          switch (visualNode.mode) {\r\n            case NODEMODE.START:\r\n              node.setDistanceToStartNode(0);\r\n              break;\r\n            case NODEMODE.TARGET:\r\n              node.setTargetNode();\r\n              break;\r\n            case NODEMODE.WALL:\r\n              node.setIsWall();\r\n              break;\r\n            default:\r\n              console.error(`Unknown NODEMODE: ${visualNode.mode}`);\r\n          }\r\n        }\r\n        nodesGrid[y].push(node);\r\n      }\r\n    }\r\n    return nodesGrid;\r\n  }\r\n\r\n  async visualizePathFinding(visitedNodes) {\r\n    for (const node of visitedNodes) {\r\n      this.setState((state) => {\r\n        const nodesGrid = [...state.nodesGrid];\r\n        let visualNode = nodesGrid[node.getYPos()][node.getXPos()];\r\n        if (visualNode.mode === NODEMODE.NONE)\r\n          visualNode.mode = NODEMODE.VISITED;\r\n        return nodesGrid;\r\n      });\r\n      await sleep(10);\r\n    }\r\n  }\r\n\r\n  async visualizeShortestPath(shortestPath) {\r\n    for (const node of shortestPath) {\r\n      this.setState((state) => {\r\n        const nodesGrid = [...state.nodesGrid];\r\n        let visualNode = nodesGrid[node.getYPos()][node.getXPos()];\r\n        if (visualNode.mode === NODEMODE.VISITED)\r\n          visualNode.mode = NODEMODE.WAY;\r\n        return nodesGrid;\r\n      });\r\n      await sleep(10);\r\n    }\r\n  }\r\n\r\n  formatNodes(grid) {\r\n    return grid.map((row, y) => {\r\n      return (\r\n        <div key={y} className=\"row justify-content-center flex-nowrap\">\r\n          {row.map((node, x) => {\r\n            return (\r\n              <NodeVisual\r\n                key={node.key}\r\n                coordinates={node.coordinates}\r\n                mode={node.mode}\r\n                nodeClicked={this.nodeClicked}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"container-fluid justify-content-center mt-2\">\r\n        <div className=\"row justify-content-center\">\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.START} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.START ? \"active\" : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.START });\r\n                }}\r\n              >\r\n                Start Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.TARGET} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.TARGET\r\n                    ? \"active\"\r\n                    : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.TARGET });\r\n                }}\r\n              >\r\n                Target Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.WALL} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.WALL ? \"active\" : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.WALL });\r\n                }}\r\n              >\r\n                Wall Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"row justify-content-center mt-2 mb-2\">\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => {\r\n              this.startPathFinding();\r\n            }}\r\n            disabled={this.state.isPathfindingRunning}\r\n          >\r\n            Animate Dijkstra\r\n          </button>\r\n        </div>\r\n        <div className=\"container\" ref={this.grid}>\r\n          {this.formatNodes(this.state.nodesGrid)}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction createNodesVisualGrid(amountX, amountY) {\r\n  var nodesGrid = [];\r\n  for (let y = 0; y < amountY; y++) {\r\n    nodesGrid[y] = [];\r\n    for (let x = 0; x < amountX; x++) {\r\n      nodesGrid[y][x] = {\r\n        key: \"\" + y + x,\r\n        coordinates: { Y: y, X: x },\r\n        mode: NODEMODE.NONE,\r\n      };\r\n    }\r\n  }\r\n  return nodesGrid;\r\n}\r\n\r\nfunction sleep(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nexport default Grid;\r\n","class PathFinder {\r\n  #unvisitedNodes;\r\n\r\n  init(grid) {\r\n    this.#unvisitedNodes = this.gridToUnvisited(grid);\r\n  }\r\n\r\n  gridToUnvisited(grid) {\r\n    // 2D Array to 1D Array\r\n    var unvisitedNodes = [];\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        unvisitedNodes.push(node);\r\n      }\r\n    }\r\n    return unvisitedNodes;\r\n  }\r\n\r\n  // doDijkstra should return path to node,\r\n  // aswell as each node visited for visual\r\n  // reconstruction\r\n  doPathFinding() {\r\n    if (!this.#unvisitedNodes) {\r\n      throw new Error(\"No nodes were set.\");\r\n    }\r\n    var visitedNodes = [];\r\n\r\n    while (this.#unvisitedNodes.length) {\r\n      this.sortByDistance(this.#unvisitedNodes);\r\n      let currentNode = this.#unvisitedNodes.shift();\r\n      if (currentNode.isWall()) {\r\n        continue;\r\n      }\r\n      if (currentNode.isTargetNode())\r\n        return {\r\n          visitedNodes,\r\n          shortestPath: this.getShortestPath(currentNode),\r\n        };\r\n      if (currentNode.getDistanceToStartNode() === Infinity)\r\n        return { visitedNodes, shortestPath: [] };\r\n      let neighbours = this.getUnvisitedNeighbours(currentNode);\r\n      this.updateNeighbours(neighbours, currentNode);\r\n      currentNode.setVisited();\r\n      visitedNodes.push(currentNode);\r\n    }\r\n  }\r\n\r\n  getShortestPath(targetNode) {\r\n    var shortestPath = [];\r\n    var lastNode = targetNode.getLastNode();\r\n    while (lastNode) {\r\n      shortestPath.push(lastNode);\r\n      lastNode = lastNode.getLastNode();\r\n    }\r\n    return shortestPath;\r\n  }\r\n\r\n  getUnvisitedNeighbours(node) {\r\n    const x = node.getXPos();\r\n    const y = node.getYPos();\r\n    return this.#unvisitedNodes.filter((node) => {\r\n      let nodeXPos = node.getXPos();\r\n      let nodeYPos = node.getYPos();\r\n      return (\r\n        !node.isVisited() &&\r\n        !node.isWall() &&\r\n        ((nodeXPos === x + 1 && nodeYPos === y) ||\r\n          (nodeXPos === x - 1 && nodeYPos === y) ||\r\n          (nodeXPos === x && nodeYPos === y + 1) ||\r\n          (nodeXPos === x && nodeYPos === y - 1))\r\n      );\r\n    });\r\n  }\r\n\r\n  updateNeighbours(neighbours, currentNode) {\r\n    var distanceOfNeighbour = currentNode.getDistanceToStartNode() + 1;\r\n    for (let neighbour of neighbours) {\r\n      neighbour.setDistanceToStartNode(distanceOfNeighbour);\r\n      neighbour.setLastNode(currentNode);\r\n    }\r\n  }\r\n\r\n  sortByDistance(nodes) {\r\n    nodes.sort(\r\n      (a, b) => a.getDistanceToStartNode() - b.getDistanceToStartNode()\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathFinder;\r\n","import React from \"react\";\nimport Grid from \"./pathfinding/GridVisualization/Grid\";\nimport PathFinder from \"./pathfinding/PathFinder/PathFinder\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <div className=\"navbar navbar-light bg-light\">\n          <span className=\"navbar-brand\">PathFinder</span>\n        </div>\n        <Grid pathFinder={new PathFinder()} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}