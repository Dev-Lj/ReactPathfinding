{"version":3,"sources":["pathfinding/GridVisualization/NodeVisual.jsx","pathfinding/PathFinder/Node.js","pathfinding/GridVisualization/Grid.jsx","pathfinding/PathFinder/PathFinder.js","pathfinding/MazeGeneration/MazeGenerator.js","App.js","serviceWorker.js","index.js"],"names":["CLICKMODE","NODEMODE","NodeVisual","this","props","coordinates","className","mode","onClick","nodeClicked","onMouseOver","e","buttons","React","Component","Node","xPos","yPos","Infinity","distance","lastNode","createNodesVisualGrid","amountX","amountY","nodesGrid","y","x","key","Y","X","sleep","ms","Promise","resolve","setTimeout","Grid","state","isPathfindingRunning","nodeClickMode","grid","createRef","bind","initGrid","screenTiltEvent","window","addEventListener","removeEventListener","afterOrientationChanged","gridProperties","calculateGridProportions","Width","Height","isValidNode","startNode","getNode","setStartNode","undefined","targetNode","setTargetNode","oldWallNodes","forEach","node","wallNode","setWallNode","setState","returnNodesGrid","doableWidth","Math","floor","current","offsetWidth","doableHeight","innerHeight","offsetTop","clickedNode","getCoordinates","isWallNode","alert","indexOf","push","splice","pathFinder","init","visualGridToNodesGrid","doPathFinding","visitedNodes","shortestPath","visualizePathFinding","visualizeShortestPath","entries","row","visualNode","setDistanceToStartNode","setIsWall","console","error","getYPos","getXPos","map","clearGrid","instructions","mazeGenerator","generateMaze","instruction","drawWall","wallDirection","wallCoordinate","holePos","from","to","type","disabled","startPathFinding","startMazeGeneration","ref","formatNodes","PathFinder","gridToUnvisited","unvisitedNodes","Error","length","sortByDistance","currentNode","shift","isWall","isTargetNode","getShortestPath","getDistanceToStartNode","neighbours","getUnvisitedNeighbours","updateNeighbours","setVisited","getLastNode","filter","nodeXPos","nodeYPos","isVisited","distanceOfNeighbour","neighbour","setLastNode","nodes","sort","a","b","generateRndNumber","min","max","excepts","number","random","includes","MazeGenerator","doMazeGenerationStep","redZones","xFrom","yFrom","xTo","yTo","relevantRedzones","redZone","Set","getRelevantRedzones","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.516a940c.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./NodeVisual.css\";\r\n\r\nexport const CLICKMODE = {\r\n  START: \"start\",\r\n  TARGET: \"target\",\r\n  WALL: \"wall\",\r\n};\r\n\r\nexport const NODEMODE = {\r\n  NONE: \"\",\r\n  START: \"start\",\r\n  TARGET: \"target\",\r\n  WALL: \"wall\",\r\n  WAY: \"way\",\r\n  VISITED: \"visited\",\r\n};\r\n\r\nexport class NodeVisual extends React.Component {\r\n  getCoordinates() {\r\n    return this.props.coordinates;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        className={\"node border \" + this.props.mode}\r\n        onClick={() => {\r\n          if (this.props.nodeClicked) {\r\n            this.props.nodeClicked(this);\r\n          }\r\n        }}\r\n        onMouseOver={(e) => {\r\n          if (e.buttons === 1) {\r\n            this.props.nodeClicked(this);\r\n          }\r\n        }}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default NodeVisual;\r\n","class Node {\r\n  #xPos;\r\n  #yPos;\r\n  #distanceToStartNode = Infinity;\r\n  #lastNode;\r\n  #isVisited = false;\r\n  #isTargetNode = false;\r\n  #isWall = false;\r\n\r\n  constructor(xPos, yPos) {\r\n    this.#xPos = xPos;\r\n    this.#yPos = yPos;\r\n  }\r\n\r\n  setDistanceToStartNode(distance) {\r\n    this.#distanceToStartNode = distance;\r\n  }\r\n\r\n  getDistanceToStartNode() {\r\n    return this.#distanceToStartNode;\r\n  }\r\n\r\n  setTargetNode() {\r\n    this.#isTargetNode = true;\r\n  }\r\n\r\n  isTargetNode() {\r\n    return this.#isTargetNode;\r\n  }\r\n\r\n  setIsWall() {\r\n    this.#isWall = true;\r\n  }\r\n\r\n  isWall() {\r\n    return this.#isWall;\r\n  }\r\n\r\n  setVisited() {\r\n    this.#isVisited = true;\r\n  }\r\n\r\n  isVisited() {\r\n    return this.#isVisited;\r\n  }\r\n\r\n  getXPos() {\r\n    return this.#xPos;\r\n  }\r\n\r\n  getYPos() {\r\n    return this.#yPos;\r\n  }\r\n\r\n  setLastNode(lastNode) {\r\n    this.#lastNode = lastNode;\r\n  }\r\n\r\n  getLastNode() {\r\n    return this.#lastNode;\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","import { NodeVisual, CLICKMODE, NODEMODE } from \"./NodeVisual\";\r\nimport Node from \"../PathFinder/Node\";\r\nimport React from \"react\";\r\n\r\nconst NODE_AMOUNT_X = 60;\r\nconst NODE_AMOUNT_Y = 60;\r\n\r\nclass Grid extends React.Component {\r\n  #startNode;\r\n  #targetNode;\r\n  #wallNodes = [];\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodesGrid: [],\r\n      isPathfindingRunning: false,\r\n      nodeClickMode: CLICKMODE.START,\r\n    };\r\n    this.grid = React.createRef();\r\n    this.nodeClicked = this.nodeClicked.bind(this);\r\n    this.initGrid = this.initGrid.bind(this);\r\n    this.screenTiltEvent = this.screenTiltEvent.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.initGrid();\r\n    window.addEventListener(\"orientationchange\", this.screenTiltEvent);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.removeEventListener(\"orientationchange\", this.screenTiltEvent);\r\n  }\r\n\r\n  /**\r\n   * Init Grid AFTER resize happened\r\n   */\r\n  screenTiltEvent() {\r\n    var afterOrientationChanged = () => {\r\n      this.initGrid();\r\n      window.removeEventListener(\"resize\", afterOrientationChanged);\r\n    };\r\n    window.addEventListener(\"resize\", afterOrientationChanged);\r\n  }\r\n\r\n  initGrid() {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n    var gridProperties = this.calculateGridProportions();\r\n    const nodesGrid = createNodesVisualGrid(\r\n      gridProperties.Width,\r\n      gridProperties.Height\r\n    );\r\n    if (this.isValidNode(this.#startNode, gridProperties)) {\r\n      let startNode = this.getNode(nodesGrid, this.#startNode.coordinates);\r\n      this.setStartNode(startNode);\r\n    } else {\r\n      this.#startNode = undefined;\r\n    }\r\n    if (this.isValidNode(this.#targetNode, gridProperties)) {\r\n      let targetNode = this.getNode(nodesGrid, this.#targetNode.coordinates);\r\n      this.setTargetNode(targetNode);\r\n    } else {\r\n      this.#targetNode = undefined;\r\n    }\r\n    let oldWallNodes = [...this.#wallNodes];\r\n    this.#wallNodes = [];\r\n    oldWallNodes.forEach((node) => {\r\n      if (this.isValidNode(node, gridProperties)) {\r\n        let wallNode = this.getNode(nodesGrid, node.coordinates);\r\n        this.setWallNode(wallNode, true);\r\n      }\r\n    });\r\n    this.setState({\r\n      nodesGrid,\r\n    });\r\n  }\r\n\r\n  clearGrid(returnNodesGrid = false) {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n    var gridProperties = this.calculateGridProportions();\r\n    const nodesGrid = createNodesVisualGrid(\r\n      gridProperties.Width,\r\n      gridProperties.Height\r\n    );\r\n    this.setState({\r\n      nodesGrid,\r\n      nodeClickMode: CLICKMODE.START,\r\n    });\r\n    if (returnNodesGrid) {\r\n      return nodesGrid;\r\n    }\r\n  }\r\n\r\n  isValidNode(node, gridProperties) {\r\n    return (\r\n      node &&\r\n      node.coordinates.X < gridProperties.Width &&\r\n      node.coordinates.Y < gridProperties.Height\r\n    );\r\n  }\r\n\r\n  calculateGridProportions() {\r\n    let doableWidth = Math.floor(this.grid.current.offsetWidth / 15) - 2;\r\n    let doableHeight =\r\n      Math.floor((window.innerHeight - this.grid.current.offsetTop) / 15) - 2;\r\n    return {\r\n      Width: doableWidth < NODE_AMOUNT_X ? doableWidth : NODE_AMOUNT_X,\r\n      Height: doableHeight < NODE_AMOUNT_Y ? doableHeight : NODE_AMOUNT_Y,\r\n    };\r\n  }\r\n\r\n  nodeClicked(node) {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n\r\n    let clickedNode = this.getNode(this.state.nodesGrid, node.getCoordinates());\r\n\r\n    switch (this.state.nodeClickMode) {\r\n      case CLICKMODE.START:\r\n        this.setStartNode(clickedNode);\r\n        this.setState({ nodeClickMode: CLICKMODE.TARGET });\r\n        break;\r\n      case CLICKMODE.TARGET:\r\n        this.setTargetNode(clickedNode);\r\n        this.setState({ nodeClickMode: CLICKMODE.WALL });\r\n        break;\r\n      case CLICKMODE.WALL:\r\n        this.setWallNode(clickedNode, !clickedNode.isWallNode);\r\n        break;\r\n      default:\r\n        alert(`Invalid clickmode: ${this.state.nodeClickMode}`);\r\n    }\r\n    this.setState({ nodesGrid: [...this.state.nodesGrid] });\r\n  }\r\n\r\n  setStartNode(clickedNode) {\r\n    if (this.#startNode) {\r\n      this.#startNode.mode = NODEMODE.NONE;\r\n    }\r\n    clickedNode.mode = NODEMODE.START;\r\n    this.#startNode = clickedNode;\r\n  }\r\n\r\n  setTargetNode(clickedNode) {\r\n    if (this.#targetNode) {\r\n      this.#targetNode.mode = NODEMODE.NONE;\r\n    }\r\n    clickedNode.mode = NODEMODE.TARGET;\r\n    this.#targetNode = clickedNode;\r\n  }\r\n\r\n  setWallNode(clickedNode, isWallNode) {\r\n    clickedNode.mode = isWallNode ? NODEMODE.WALL : NODEMODE.NONE;\r\n    if (isWallNode && this.#wallNodes.indexOf(clickedNode) === -1) {\r\n      this.#wallNodes.push(clickedNode);\r\n    } else if (!isWallNode && this.#wallNodes.indexOf(clickedNode) !== -1) {\r\n      this.#wallNodes.splice(this.#wallNodes.indexOf(clickedNode), 1);\r\n    }\r\n  }\r\n\r\n  getNode(grid, coordinates) {\r\n    return grid[coordinates.Y][coordinates.X];\r\n  }\r\n\r\n  async startPathFinding() {\r\n    if (this.#startNode === undefined || this.#targetNode === undefined) {\r\n      alert(\"Start- or targetnode missing. Cannot start Dijkstra\");\r\n      return false;\r\n    }\r\n    this.setState({ isPathfindingRunning: true });\r\n    this.props.pathFinder.init(this.visualGridToNodesGrid());\r\n    let { visitedNodes, shortestPath } = this.props.pathFinder.doPathFinding();\r\n    await this.visualizePathFinding(visitedNodes);\r\n    await this.visualizeShortestPath(shortestPath);\r\n    await sleep(1000);\r\n    this.setState({ isPathfindingRunning: false });\r\n    this.initGrid();\r\n  }\r\n\r\n  /**\r\n   * Convert visual node objects to node objects for pathfinder to use\r\n   */\r\n  visualGridToNodesGrid() {\r\n    var nodesGrid = [];\r\n    for (let [y, row] of this.state.nodesGrid.entries()) {\r\n      nodesGrid.push([]);\r\n      for (let visualNode of row) {\r\n        let node = new Node(visualNode.coordinates.X, visualNode.coordinates.Y);\r\n        if (visualNode.mode !== NODEMODE.NONE) {\r\n          switch (visualNode.mode) {\r\n            case NODEMODE.START:\r\n              node.setDistanceToStartNode(0);\r\n              break;\r\n            case NODEMODE.TARGET:\r\n              node.setTargetNode();\r\n              break;\r\n            case NODEMODE.WALL:\r\n              node.setIsWall();\r\n              break;\r\n            default:\r\n              console.error(`Unknown NODEMODE: ${visualNode.mode}`);\r\n          }\r\n        }\r\n        nodesGrid[y].push(node);\r\n      }\r\n    }\r\n    return nodesGrid;\r\n  }\r\n\r\n  async visualizePathFinding(visitedNodes) {\r\n    for (const node of visitedNodes) {\r\n      this.setState((state) => {\r\n        const nodesGrid = [...state.nodesGrid];\r\n        let visualNode = nodesGrid[node.getYPos()][node.getXPos()];\r\n        if (visualNode.mode === NODEMODE.NONE)\r\n          visualNode.mode = NODEMODE.VISITED;\r\n        return nodesGrid;\r\n      });\r\n      await sleep(10);\r\n    }\r\n  }\r\n\r\n  async visualizeShortestPath(shortestPath) {\r\n    for (const node of shortestPath) {\r\n      this.setState((state) => {\r\n        const nodesGrid = [...state.nodesGrid];\r\n        let visualNode = nodesGrid[node.getYPos()][node.getXPos()];\r\n        if (visualNode.mode === NODEMODE.VISITED)\r\n          visualNode.mode = NODEMODE.WAY;\r\n        return nodesGrid;\r\n      });\r\n      await sleep(10);\r\n    }\r\n  }\r\n\r\n  formatNodes(grid) {\r\n    return grid.map((row, y) => {\r\n      return (\r\n        <div key={y} className=\"row justify-content-center flex-nowrap\">\r\n          {row.map((node, x) => {\r\n            return (\r\n              <NodeVisual\r\n                key={node.key}\r\n                coordinates={node.coordinates}\r\n                mode={node.mode}\r\n                nodeClicked={this.nodeClicked}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      );\r\n    });\r\n  }\r\n\r\n  async startMazeGeneration() {\r\n    const nodesGrid = this.clearGrid(true);\r\n    var instructions;\r\n    instructions = this.props.mazeGenerator.generateMaze(nodesGrid);\r\n    for (const instruction of instructions) {\r\n      this.props.mazeGenerator.drawWall(nodesGrid, instruction.wallDirection, instruction.wallCoordinate, instruction.holePos, instruction.from, instruction.to);\r\n      this.setState({\r\n        nodesGrid\r\n      });\r\n      // If the Maze-generation should be animated, uncomment\r\n      // await sleep(10);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"container-fluid justify-content-center mt-2\">\r\n        <div className=\"row justify-content-center\">\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.START} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.START ? \"active\" : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.START });\r\n                }}\r\n              >\r\n                Start Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.TARGET} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.TARGET\r\n                    ? \"active\"\r\n                    : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.TARGET });\r\n                }}\r\n              >\r\n                Target Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.WALL} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.WALL ? \"active\" : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.WALL });\r\n                }}\r\n              >\r\n                Wall Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"row justify-content-center mt-2 mb-2\">\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-secondary btn-sm mr-2\"\r\n            onClick={() => {\r\n              this.clearGrid();\r\n            }}\r\n            disabled={this.state.isPathfindingRunning}\r\n          >\r\n            Clear Grid\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => {\r\n              this.startPathFinding();\r\n            }}\r\n            disabled={this.state.isPathfindingRunning}\r\n          >\r\n            Animate Dijkstra\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-secondary btn-sm ml-2\"\r\n            onClick={() => {\r\n              this.startMazeGeneration();\r\n            }}\r\n            disabled={this.state.isPathfindingRunning}\r\n          >\r\n            Generate Maze\r\n          </button>\r\n        </div>\r\n        <div className=\"container\" ref={this.grid}>\r\n          {this.formatNodes(this.state.nodesGrid)}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction createNodesVisualGrid(amountX, amountY) {\r\n  var nodesGrid = [];\r\n  for (let y = 0; y < amountY; y++) {\r\n    nodesGrid[y] = [];\r\n    for (let x = 0; x < amountX; x++) {\r\n      nodesGrid[y][x] = {\r\n        key: \"\" + y + x,\r\n        coordinates: { Y: y, X: x },\r\n        mode: NODEMODE.NONE,\r\n      };\r\n    }\r\n  }\r\n  return nodesGrid;\r\n}\r\n\r\nfunction sleep(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nexport default Grid;\r\n","class PathFinder {\r\n  #unvisitedNodes;\r\n\r\n  init(grid) {\r\n    this.#unvisitedNodes = this.gridToUnvisited(grid);\r\n  }\r\n\r\n  gridToUnvisited(grid) {\r\n    // 2D Array to 1D Array\r\n    var unvisitedNodes = [];\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        unvisitedNodes.push(node);\r\n      }\r\n    }\r\n    return unvisitedNodes;\r\n  }\r\n\r\n  // doDijkstra should return path to node,\r\n  // aswell as each node visited for visual\r\n  // reconstruction\r\n  doPathFinding() {\r\n    if (!this.#unvisitedNodes) {\r\n      throw new Error(\"No nodes were set.\");\r\n    }\r\n    var visitedNodes = [];\r\n\r\n    while (this.#unvisitedNodes.length) {\r\n      this.sortByDistance(this.#unvisitedNodes);\r\n      let currentNode = this.#unvisitedNodes.shift();\r\n      if (currentNode.isWall()) {\r\n        continue;\r\n      }\r\n      if (currentNode.isTargetNode())\r\n        return {\r\n          visitedNodes,\r\n          shortestPath: this.getShortestPath(currentNode),\r\n        };\r\n      if (currentNode.getDistanceToStartNode() === Infinity)\r\n        return { visitedNodes, shortestPath: [] };\r\n      let neighbours = this.getUnvisitedNeighbours(currentNode);\r\n      this.updateNeighbours(neighbours, currentNode);\r\n      currentNode.setVisited();\r\n      visitedNodes.push(currentNode);\r\n    }\r\n  }\r\n\r\n  getShortestPath(targetNode) {\r\n    var shortestPath = [];\r\n    var lastNode = targetNode.getLastNode();\r\n    while (lastNode) {\r\n      shortestPath.push(lastNode);\r\n      lastNode = lastNode.getLastNode();\r\n    }\r\n    return shortestPath;\r\n  }\r\n\r\n  getUnvisitedNeighbours(node) {\r\n    const x = node.getXPos();\r\n    const y = node.getYPos();\r\n    return this.#unvisitedNodes.filter((node) => {\r\n      let nodeXPos = node.getXPos();\r\n      let nodeYPos = node.getYPos();\r\n      return (\r\n        !node.isVisited() &&\r\n        !node.isWall() &&\r\n        ((nodeXPos === x + 1 && nodeYPos === y) ||\r\n          (nodeXPos === x - 1 && nodeYPos === y) ||\r\n          (nodeXPos === x && nodeYPos === y + 1) ||\r\n          (nodeXPos === x && nodeYPos === y - 1))\r\n      );\r\n    });\r\n  }\r\n\r\n  updateNeighbours(neighbours, currentNode) {\r\n    var distanceOfNeighbour = currentNode.getDistanceToStartNode() + 1;\r\n    for (let neighbour of neighbours) {\r\n      neighbour.setDistanceToStartNode(distanceOfNeighbour);\r\n      neighbour.setLastNode(currentNode);\r\n    }\r\n  }\r\n\r\n  sortByDistance(nodes) {\r\n    nodes.sort(\r\n      (a, b) => a.getDistanceToStartNode() - b.getDistanceToStartNode()\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathFinder;\r\n","import { NODEMODE } from \"../GridVisualization/NodeVisual\";\r\n\r\nconst DIRECTION_Y = 0;\r\nconst DIRECTION_X = 1;\r\n\r\n/**\r\n * Generate random number INCLUDING min and max excluding excepts\r\n * @param {Number} min\r\n * @param {Number} max\r\n * @param {Array} excepts\r\n */\r\nfunction generateRndNumber(min, max, excepts = []) {\r\n  if (excepts.length > max - min) {\r\n    // No more available numbers with given exceptions\r\n    throw new Error(\"No possible number with given excepts\");\r\n  }\r\n  var number = Math.floor(Math.random() * (max - min + 1) + min);\r\n  if (excepts.includes(number)) {\r\n    return generateRndNumber(min, max, excepts);\r\n  } else {\r\n    return number;\r\n  }\r\n}\r\n\r\n/**\r\n * Raw concept based on maze generation described in this blog:\r\n * http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm\r\n */\r\nclass MazeGenerator {\r\n  /**\r\n   * Function to call to start recursive maze generation\r\n   * @param {Array} grid\r\n   * @returns {Array} instructions to draw walls\r\n   */\r\n  generateMaze(grid) {\r\n    return this.doMazeGenerationStep(\r\n      grid,\r\n      DIRECTION_Y,\r\n      0,\r\n      0,\r\n      grid[0].length - 1,\r\n      grid.length - 1,\r\n      [],\r\n      []\r\n    );\r\n  }\r\n  /**\r\n   * Get relevant tiles to avoid for given square\r\n   * @param {Array} redZones\r\n   * @param {Number} xFrom\r\n   * @param {Number} yFrom\r\n   * @param {Number} xTo\r\n   * @param {Number} yTo\r\n   * @param {Number} wallDirection\r\n   * @returns {Array} Array of Numbers to avoid for Wall generation\r\n   */\r\n  getRelevantRedzones(redZones, xFrom, yFrom, xTo, yTo, wallDirection) {\r\n    let relevantRedzones = redZones.filter((redZone) => {\r\n      return (\r\n        redZone.y >= yFrom &&\r\n        redZone.y <= yTo &&\r\n        redZone.x >= xFrom &&\r\n        redZone.x <= xTo\r\n      );\r\n    });\r\n    relevantRedzones = relevantRedzones.map((redZone) =>\r\n      wallDirection === DIRECTION_X ? redZone.y : redZone.x\r\n    );\r\n    return [...new Set(relevantRedzones)];\r\n  }\r\n\r\n  /**\r\n   * Do recursive step to go down tree of maze\r\n   * @param {Array} grid\r\n   * @param {Number} wallDirection\r\n   * @param {Number} xFrom X-Coordinate of first tile in square\r\n   * @param {Number} yFrom Y-Coordinate of first tile in square\r\n   * @param {Number} xTo X-Coordinate of last tile in square\r\n   * @param {Number} yTo Y-Coordinate of last tile in squre\r\n   * @param {Array} instructions\r\n   * @param {Array} redZones Array of tiles to avoid to not clog maze\r\n   * @returns {Array} instructions for current level of tree\r\n   */\r\n  doMazeGenerationStep(\r\n    grid,\r\n    wallDirection,\r\n    xFrom,\r\n    yFrom,\r\n    xTo,\r\n    yTo,\r\n    instructions,\r\n    redZones\r\n  ) {\r\n    //Check if current square is large enough to draw wall\r\n    if (yTo - yFrom >= 2 && xTo - xFrom >= 2) {\r\n      var wallCoordinate;\r\n      var holePos;\r\n\r\n      if (wallDirection === DIRECTION_X) {\r\n        let excepts = this.getRelevantRedzones(\r\n          redZones,\r\n          xFrom,\r\n          yFrom + 1,\r\n          xTo,\r\n          yTo - 1,\r\n          wallDirection\r\n        );\r\n        try {\r\n          wallCoordinate = generateRndNumber(yFrom + 1, yTo - 1, excepts);\r\n        } catch {\r\n          // No wallcoordinate available with given exceptions -> bottom of tree reached\r\n          return instructions;\r\n        }\r\n        holePos = generateRndNumber(xFrom, xTo);\r\n        redZones.push({ x: holePos, y: wallCoordinate - 1 });\r\n        redZones.push({ x: holePos, y: wallCoordinate + 1 });\r\n      } else {\r\n        let excepts = this.getRelevantRedzones(\r\n          redZones,\r\n          xFrom + 1,\r\n          yFrom,\r\n          xTo - 1,\r\n          yTo,\r\n          wallDirection\r\n        );\r\n        try {\r\n          wallCoordinate = generateRndNumber(xFrom + 1, xTo - 1, excepts);\r\n        } catch {\r\n          // No wallcoordinate available with given exceptions -> bottom of tree reached\r\n          return instructions;\r\n        }\r\n        holePos = generateRndNumber(yFrom, yTo);\r\n        redZones.push({ x: wallCoordinate - 1, y: holePos });\r\n        redZones.push({ x: wallCoordinate + 1, y: holePos });\r\n      }\r\n\r\n      instructions.push({\r\n        wallDirection,\r\n        wallCoordinate,\r\n        holePos,\r\n        from: wallDirection === DIRECTION_Y ? yFrom : xFrom,\r\n        to: wallDirection === DIRECTION_Y ? yTo : xTo,\r\n      });\r\n      //Follow branch of child 1\r\n      instructions = this.doMazeGenerationStep(\r\n        grid,\r\n        wallDirection === DIRECTION_Y ? DIRECTION_X : DIRECTION_Y,\r\n        xFrom,\r\n        yFrom,\r\n        wallDirection === DIRECTION_Y ? wallCoordinate - 1 : xTo,\r\n        wallDirection === DIRECTION_X ? wallCoordinate - 1 : yTo,\r\n        instructions,\r\n        redZones\r\n      );\r\n      //Follow branch of child 2\r\n      instructions = this.doMazeGenerationStep(\r\n        grid,\r\n        wallDirection === DIRECTION_Y ? DIRECTION_X : DIRECTION_Y,\r\n        wallDirection === DIRECTION_Y ? wallCoordinate + 1 : xFrom,\r\n        wallDirection === DIRECTION_X ? wallCoordinate + 1 : yFrom,\r\n        xTo,\r\n        yTo,\r\n        instructions,\r\n        redZones\r\n      );\r\n    }\r\n    return instructions;\r\n    // Bottom of tree reached\r\n  }\r\n\r\n  /**\r\n   * Draw wall with given instructions\r\n   * @param {Array} grid\r\n   * @param {Number} wallDirection\r\n   * @param {Number} wallCoordinate\r\n   * @param {Number} holePos\r\n   * @param {Number} from First tile of wall (including)\r\n   * @param {Number} to  Last tile of wall (including)\r\n   */\r\n  drawWall(grid, wallDirection, wallCoordinate, holePos, from, to) {\r\n    if (wallDirection === DIRECTION_X) {\r\n      // Draw wall in x direction accross piece to separate\r\n      for (let xPos = from; xPos <= to; xPos++) {\r\n        if (xPos !== holePos) {\r\n          grid[wallCoordinate][xPos].mode = NODEMODE.WALL;\r\n        }\r\n      }\r\n    } else {\r\n      // Draw wall in y direction accross piece to separate\r\n      for (let yPos = from; yPos <= to; yPos++) {\r\n        if (yPos !== holePos) {\r\n          grid[yPos][wallCoordinate].mode = NODEMODE.WALL;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default MazeGenerator;\r\n","import React from \"react\";\nimport Grid from \"./pathfinding/GridVisualization/Grid\";\nimport PathFinder from \"./pathfinding/PathFinder/PathFinder\";\nimport MazeGenerator from \"./pathfinding/MazeGeneration/MazeGenerator\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <div className=\"navbar navbar-light bg-light\">\n          <span className=\"navbar-brand\">PathFinder</span>\n        </div>\n        <Grid\n          pathFinder={new PathFinder()}\n          mazeGenerator={new MazeGenerator()}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}