{"version":3,"sources":["pathfinding/GridVisualization/NodeVisual.jsx","pathfinding/PathFinder/Node.js","pathfinding/GridVisualization/Grid.jsx","pathfinding/PathFinder/PathFinder.js","pathfinding/MazeGeneration/MazeGenerator.js","App.js","serviceWorker.js","index.js"],"names":["CLICKMODE","NODEMODE","NodeVisual","this","props","coordinates","className","mode","onClick","nodeClicked","onMouseOver","e","buttons","React","Component","Node","xPos","yPos","Infinity","distance","lastNode","createNodesVisualGrid","amountX","amountY","nodesGrid","y","x","key","Y","X","sleep","ms","Promise","resolve","setTimeout","Grid","state","isPathfindingRunning","nodeClickMode","grid","createRef","bind","initGrid","screenTiltEvent","abortAnimation","window","addEventListener","removeEventListener","afterOrientationChanged","gridProperties","calculateGridProportions","Width","Height","isValidNode","startNode","getNode","setStartNode","undefined","targetNode","setTargetNode","oldWallNodes","forEach","node","wallNode","setWallNode","setState","returnNodesGrid","doableWidth","Math","floor","current","offsetWidth","doableHeight","innerHeight","offsetTop","clickedNode","getCoordinates","isWallNode","alert","indexOf","push","splice","pathFinder","init","visualGridToNodesGrid","doPathFinding","visitedNodes","shortestPath","visualizePathFinding","visualizeShortestPath","entries","row","visualNode","setDistanceToStartNode","setIsWall","console","error","getYPos","getXPos","map","clearGrid","instructions","mazeGenerator","generateMaze","instruction","walls","drawWall","wallDirection","wallCoordinate","holePos","from","to","concat","hidden","type","startPathFinding","startMazeGeneration","ref","formatNodes","PathFinder","gridToUnvisited","unvisitedNodes","Error","length","sortByDistance","currentNode","shift","isWall","isTargetNode","getShortestPath","getDistanceToStartNode","neighbours","getUnvisitedNeighbours","updateNeighbours","setVisited","getLastNode","filter","nodeXPos","nodeYPos","isVisited","distanceOfNeighbour","neighbour","setLastNode","nodes","sort","a","b","generateRndNumber","min","max","excepts","number","random","includes","MazeGenerator","doMazeGenerationStep","redZones","xFrom","yFrom","xTo","yTo","relevantRedzones","redZone","Set","getRelevantRedzones","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.ce685705.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./NodeVisual.css\";\r\n\r\nexport const CLICKMODE = {\r\n  START: \"start\",\r\n  TARGET: \"target\",\r\n  WALL: \"wall\",\r\n};\r\n\r\nexport const NODEMODE = {\r\n  NONE: \"\",\r\n  START: \"start\",\r\n  TARGET: \"target\",\r\n  WALL: \"wall\",\r\n  WAY: \"way\",\r\n  VISITED: \"visited\",\r\n};\r\n\r\nexport class NodeVisual extends React.Component {\r\n  getCoordinates() {\r\n    return this.props.coordinates;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        className={\"node border \" + this.props.mode}\r\n        onClick={() => {\r\n          if (this.props.nodeClicked) {\r\n            this.props.nodeClicked(this);\r\n          }\r\n        }}\r\n        onMouseOver={(e) => {\r\n          if (e.buttons === 1) {\r\n            this.props.nodeClicked(this);\r\n          }\r\n        }}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default NodeVisual;\r\n","class Node {\r\n  #xPos;\r\n  #yPos;\r\n  #distanceToStartNode = Infinity;\r\n  #lastNode;\r\n  #isVisited = false;\r\n  #isTargetNode = false;\r\n  #isWall = false;\r\n\r\n  constructor(xPos, yPos) {\r\n    this.#xPos = xPos;\r\n    this.#yPos = yPos;\r\n  }\r\n\r\n  setDistanceToStartNode(distance) {\r\n    this.#distanceToStartNode = distance;\r\n  }\r\n\r\n  getDistanceToStartNode() {\r\n    return this.#distanceToStartNode;\r\n  }\r\n\r\n  setTargetNode() {\r\n    this.#isTargetNode = true;\r\n  }\r\n\r\n  isTargetNode() {\r\n    return this.#isTargetNode;\r\n  }\r\n\r\n  setIsWall() {\r\n    this.#isWall = true;\r\n  }\r\n\r\n  isWall() {\r\n    return this.#isWall;\r\n  }\r\n\r\n  setVisited() {\r\n    this.#isVisited = true;\r\n  }\r\n\r\n  isVisited() {\r\n    return this.#isVisited;\r\n  }\r\n\r\n  getXPos() {\r\n    return this.#xPos;\r\n  }\r\n\r\n  getYPos() {\r\n    return this.#yPos;\r\n  }\r\n\r\n  setLastNode(lastNode) {\r\n    this.#lastNode = lastNode;\r\n  }\r\n\r\n  getLastNode() {\r\n    return this.#lastNode;\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","import { NodeVisual, CLICKMODE, NODEMODE } from \"./NodeVisual\";\r\nimport Node from \"../PathFinder/Node\";\r\nimport React from \"react\";\r\n\r\nconst NODE_AMOUNT_X = 60;\r\nconst NODE_AMOUNT_Y = 60;\r\n\r\nclass Grid extends React.Component {\r\n  #startNode;\r\n  #targetNode;\r\n  #wallNodes = [];\r\n  #isPathFindingAborted = false;\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      nodesGrid: [],\r\n      isPathfindingRunning: false,\r\n      nodeClickMode: CLICKMODE.START,\r\n    };\r\n    this.grid = React.createRef();\r\n    this.nodeClicked = this.nodeClicked.bind(this);\r\n    this.initGrid = this.initGrid.bind(this);\r\n    this.screenTiltEvent = this.screenTiltEvent.bind(this);\r\n    this.abortAnimation = this.abortAnimation.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.initGrid();\r\n    window.addEventListener(\"orientationchange\", this.screenTiltEvent);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.removeEventListener(\"orientationchange\", this.screenTiltEvent);\r\n  }\r\n\r\n  /**\r\n   * Init Grid AFTER resize happened\r\n   */\r\n  screenTiltEvent() {\r\n    var afterOrientationChanged = () => {\r\n      this.initGrid();\r\n      window.removeEventListener(\"resize\", afterOrientationChanged);\r\n    };\r\n    window.addEventListener(\"resize\", afterOrientationChanged);\r\n  }\r\n\r\n  initGrid() {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n    var gridProperties = this.calculateGridProportions();\r\n    const nodesGrid = createNodesVisualGrid(\r\n      gridProperties.Width,\r\n      gridProperties.Height\r\n    );\r\n    if (this.isValidNode(this.#startNode, gridProperties)) {\r\n      let startNode = this.getNode(nodesGrid, this.#startNode.coordinates);\r\n      this.setStartNode(startNode);\r\n    } else {\r\n      this.#startNode = undefined;\r\n    }\r\n    if (this.isValidNode(this.#targetNode, gridProperties)) {\r\n      let targetNode = this.getNode(nodesGrid, this.#targetNode.coordinates);\r\n      this.setTargetNode(targetNode);\r\n    } else {\r\n      this.#targetNode = undefined;\r\n    }\r\n    let oldWallNodes = [...this.#wallNodes];\r\n    this.#wallNodes = [];\r\n    oldWallNodes.forEach((node) => {\r\n      if (this.isValidNode(node, gridProperties)) {\r\n        let wallNode = this.getNode(nodesGrid, node.coordinates);\r\n        this.setWallNode(wallNode, true);\r\n      }\r\n    });\r\n    this.setState({\r\n      nodesGrid,\r\n    });\r\n  }\r\n\r\n  clearGrid(returnNodesGrid = false) {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n    var gridProperties = this.calculateGridProportions();\r\n    const nodesGrid = createNodesVisualGrid(\r\n      gridProperties.Width,\r\n      gridProperties.Height\r\n    );\r\n    this.setState({\r\n      nodesGrid,\r\n      nodeClickMode: CLICKMODE.START,\r\n    });\r\n    this.#startNode = undefined;\r\n    this.#targetNode = undefined;\r\n    this.#wallNodes = [];\r\n    if (returnNodesGrid) {\r\n      return nodesGrid;\r\n    }\r\n  }\r\n\r\n  abortAnimation() {\r\n    this.setState({ isPathfindingRunning: false });\r\n    this.#isPathFindingAborted = true;\r\n  }\r\n\r\n  isValidNode(node, gridProperties) {\r\n    return (\r\n      node &&\r\n      node.coordinates.X < gridProperties.Width &&\r\n      node.coordinates.Y < gridProperties.Height\r\n    );\r\n  }\r\n\r\n  calculateGridProportions() {\r\n    let doableWidth = Math.floor(this.grid.current.offsetWidth / 15) - 2;\r\n    let doableHeight =\r\n      Math.floor((window.innerHeight - this.grid.current.offsetTop) / 15) - 2;\r\n    return {\r\n      Width: doableWidth < NODE_AMOUNT_X ? doableWidth : NODE_AMOUNT_X,\r\n      Height: doableHeight < NODE_AMOUNT_Y ? doableHeight : NODE_AMOUNT_Y,\r\n    };\r\n  }\r\n\r\n  nodeClicked(node) {\r\n    if (this.state.isPathfindingRunning) {\r\n      return;\r\n    }\r\n\r\n    let clickedNode = this.getNode(this.state.nodesGrid, node.getCoordinates());\r\n\r\n    switch (this.state.nodeClickMode) {\r\n      case CLICKMODE.START:\r\n        this.setStartNode(clickedNode);\r\n        this.setState({ nodeClickMode: CLICKMODE.TARGET });\r\n        break;\r\n      case CLICKMODE.TARGET:\r\n        this.setTargetNode(clickedNode);\r\n        this.setState({ nodeClickMode: CLICKMODE.WALL });\r\n        break;\r\n      case CLICKMODE.WALL:\r\n        this.setWallNode(clickedNode, !clickedNode.isWallNode);\r\n        break;\r\n      default:\r\n        alert(`Invalid clickmode: ${this.state.nodeClickMode}`);\r\n    }\r\n    this.setState({ nodesGrid: [...this.state.nodesGrid] });\r\n  }\r\n\r\n  setStartNode(clickedNode) {\r\n    if (this.#startNode) {\r\n      this.#startNode.mode = NODEMODE.NONE;\r\n    }\r\n    clickedNode.mode = NODEMODE.START;\r\n    this.#startNode = clickedNode;\r\n  }\r\n\r\n  setTargetNode(clickedNode) {\r\n    if (this.#targetNode) {\r\n      this.#targetNode.mode = NODEMODE.NONE;\r\n    }\r\n    clickedNode.mode = NODEMODE.TARGET;\r\n    this.#targetNode = clickedNode;\r\n  }\r\n\r\n  setWallNode(clickedNode, isWallNode) {\r\n    clickedNode.mode = isWallNode ? NODEMODE.WALL : NODEMODE.NONE;\r\n    if (isWallNode && this.#wallNodes.indexOf(clickedNode) === -1) {\r\n      this.#wallNodes.push(clickedNode);\r\n    } else if (!isWallNode && this.#wallNodes.indexOf(clickedNode) !== -1) {\r\n      this.#wallNodes.splice(this.#wallNodes.indexOf(clickedNode), 1);\r\n    }\r\n  }\r\n\r\n  getNode(grid, coordinates) {\r\n    return grid[coordinates.Y][coordinates.X];\r\n  }\r\n\r\n  async startPathFinding() {\r\n    if (this.#startNode === undefined || this.#targetNode === undefined) {\r\n      alert(\"Start- or targetnode missing. Cannot start Dijkstra\");\r\n      return false;\r\n    }\r\n    this.setState({ isPathfindingRunning: true });\r\n    this.props.pathFinder.init(this.visualGridToNodesGrid());\r\n    let { visitedNodes, shortestPath } = this.props.pathFinder.doPathFinding();\r\n    await this.visualizePathFinding(visitedNodes);\r\n    await this.visualizeShortestPath(shortestPath);\r\n    if (!this.#isPathFindingAborted) {\r\n      await sleep(1000);\r\n    } else {\r\n      this.#isPathFindingAborted = false;\r\n    }\r\n    this.setState({ isPathfindingRunning: false });\r\n    this.initGrid();\r\n  }\r\n\r\n  /**\r\n   * Convert visual node objects to node objects for pathfinder to use\r\n   */\r\n  visualGridToNodesGrid() {\r\n    var nodesGrid = [];\r\n    for (let [y, row] of this.state.nodesGrid.entries()) {\r\n      nodesGrid.push([]);\r\n      for (let visualNode of row) {\r\n        let node = new Node(visualNode.coordinates.X, visualNode.coordinates.Y);\r\n        if (visualNode.mode !== NODEMODE.NONE) {\r\n          switch (visualNode.mode) {\r\n            case NODEMODE.START:\r\n              node.setDistanceToStartNode(0);\r\n              break;\r\n            case NODEMODE.TARGET:\r\n              node.setTargetNode();\r\n              break;\r\n            case NODEMODE.WALL:\r\n              node.setIsWall();\r\n              break;\r\n            default:\r\n              console.error(`Unknown NODEMODE: ${visualNode.mode}`);\r\n          }\r\n        }\r\n        nodesGrid[y].push(node);\r\n      }\r\n    }\r\n    return nodesGrid;\r\n  }\r\n\r\n  async visualizePathFinding(visitedNodes) {\r\n    for (const node of visitedNodes) {\r\n      this.setState((state) => {\r\n        const nodesGrid = [...state.nodesGrid];\r\n        let visualNode = nodesGrid[node.getYPos()][node.getXPos()];\r\n        if (visualNode.mode === NODEMODE.NONE)\r\n          visualNode.mode = NODEMODE.VISITED;\r\n        return nodesGrid;\r\n      });\r\n      if (this.#isPathFindingAborted) {\r\n        return;\r\n      }\r\n      await sleep(10);\r\n    }\r\n  }\r\n\r\n  async visualizeShortestPath(shortestPath) {\r\n    for (const node of shortestPath) {\r\n      if (this.#isPathFindingAborted) {\r\n        return;\r\n      }\r\n      this.setState((state) => {\r\n        const nodesGrid = [...state.nodesGrid];\r\n        let visualNode = nodesGrid[node.getYPos()][node.getXPos()];\r\n        if (visualNode.mode === NODEMODE.VISITED)\r\n          visualNode.mode = NODEMODE.WAY;\r\n        return nodesGrid;\r\n      });\r\n      await sleep(10);\r\n    }\r\n  }\r\n\r\n  formatNodes(grid) {\r\n    return grid.map((row, y) => {\r\n      return (\r\n        <div key={y} className=\"row justify-content-center flex-nowrap\">\r\n          {row.map((node, x) => {\r\n            return (\r\n              <NodeVisual\r\n                key={node.key}\r\n                coordinates={node.coordinates}\r\n                mode={node.mode}\r\n                nodeClicked={this.nodeClicked}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      );\r\n    });\r\n  }\r\n\r\n  async startMazeGeneration() {\r\n    const nodesGrid = this.clearGrid(true);\r\n    var instructions;\r\n    instructions = this.props.mazeGenerator.generateMaze(nodesGrid);\r\n    for (const instruction of instructions) {\r\n      let walls = this.props.mazeGenerator.drawWall(nodesGrid, instruction.wallDirection, instruction.wallCoordinate, instruction.holePos, instruction.from, instruction.to);\r\n      this.#wallNodes = this.#wallNodes.concat(walls);\r\n      this.setState({\r\n        nodesGrid\r\n      });\r\n      // If the Maze-generation should be animated, uncomment\r\n      // await sleep(10);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"container-fluid justify-content-center mt-2\">\r\n        <div className=\"row justify-content-center\">\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.START} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.START ? \"active\" : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.START });\r\n                }}\r\n              >\r\n                Start Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.TARGET} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.TARGET\r\n                    ? \"active\"\r\n                    : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.TARGET });\r\n                }}\r\n              >\r\n                Target Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"col-md-2 justify-content-center\">\r\n            <div className=\"form-check\">\r\n              <div className=\"form-check-input\">\r\n                <NodeVisual mode={NODEMODE.WALL} />\r\n              </div>\r\n              <label\r\n                className={\r\n                  \"form-check-label \" +\r\n                  (this.state.nodeClickMode === CLICKMODE.WALL ? \"active\" : \"\")\r\n                }\r\n                onClick={() => {\r\n                  this.setState({ nodeClickMode: CLICKMODE.WALL });\r\n                }}\r\n              >\r\n                Wall Node\r\n              </label>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"row justify-content-center mt-2 mb-2\" hidden={this.state.isPathfindingRunning}>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-secondary btn-sm mr-2\"\r\n            onClick={() => {\r\n              this.clearGrid();\r\n            }}\r\n          >\r\n            Clear Grid\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => {\r\n              this.startPathFinding();\r\n            }}\r\n          >\r\n            Animate Dijkstra\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-secondary btn-sm ml-2\"\r\n            onClick={() => {\r\n              this.startMazeGeneration();\r\n            }}\r\n          >\r\n            Generate Maze\r\n          </button>\r\n        </div>\r\n        <div className=\"row justify-content-center mt-2 mb-2\" hidden={!this.state.isPathfindingRunning}>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => {\r\n              this.abortAnimation();\r\n            }}\r\n          >Abort Animation</button>\r\n        </div>\r\n        <div className=\"container\" ref={this.grid}>\r\n          {this.formatNodes(this.state.nodesGrid)}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction createNodesVisualGrid(amountX, amountY) {\r\n  var nodesGrid = [];\r\n  for (let y = 0; y < amountY; y++) {\r\n    nodesGrid[y] = [];\r\n    for (let x = 0; x < amountX; x++) {\r\n      nodesGrid[y][x] = {\r\n        key: \"\" + y + x,\r\n        coordinates: { Y: y, X: x },\r\n        mode: NODEMODE.NONE,\r\n      };\r\n    }\r\n  }\r\n  return nodesGrid;\r\n}\r\n\r\nfunction sleep(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nexport default Grid;\r\n","class PathFinder {\r\n  #unvisitedNodes;\r\n\r\n  init(grid) {\r\n    this.#unvisitedNodes = this.gridToUnvisited(grid);\r\n  }\r\n\r\n  gridToUnvisited(grid) {\r\n    // 2D Array to 1D Array\r\n    var unvisitedNodes = [];\r\n    for (let row of grid) {\r\n      for (let node of row) {\r\n        unvisitedNodes.push(node);\r\n      }\r\n    }\r\n    return unvisitedNodes;\r\n  }\r\n\r\n  // doDijkstra should return path to node,\r\n  // aswell as each node visited for visual\r\n  // reconstruction\r\n  doPathFinding() {\r\n    if (!this.#unvisitedNodes) {\r\n      throw new Error(\"No nodes were set.\");\r\n    }\r\n    var visitedNodes = [];\r\n\r\n    while (this.#unvisitedNodes.length) {\r\n      this.sortByDistance(this.#unvisitedNodes);\r\n      let currentNode = this.#unvisitedNodes.shift();\r\n      if (currentNode.isWall()) {\r\n        continue;\r\n      }\r\n      if (currentNode.isTargetNode())\r\n        return {\r\n          visitedNodes,\r\n          shortestPath: this.getShortestPath(currentNode),\r\n        };\r\n      if (currentNode.getDistanceToStartNode() === Infinity)\r\n        return { visitedNodes, shortestPath: [] };\r\n      let neighbours = this.getUnvisitedNeighbours(currentNode);\r\n      this.updateNeighbours(neighbours, currentNode);\r\n      currentNode.setVisited();\r\n      visitedNodes.push(currentNode);\r\n    }\r\n  }\r\n\r\n  getShortestPath(targetNode) {\r\n    var shortestPath = [];\r\n    var lastNode = targetNode.getLastNode();\r\n    while (lastNode) {\r\n      shortestPath.push(lastNode);\r\n      lastNode = lastNode.getLastNode();\r\n    }\r\n    return shortestPath;\r\n  }\r\n\r\n  getUnvisitedNeighbours(node) {\r\n    const x = node.getXPos();\r\n    const y = node.getYPos();\r\n    return this.#unvisitedNodes.filter((node) => {\r\n      let nodeXPos = node.getXPos();\r\n      let nodeYPos = node.getYPos();\r\n      return (\r\n        !node.isVisited() &&\r\n        !node.isWall() &&\r\n        ((nodeXPos === x + 1 && nodeYPos === y) ||\r\n          (nodeXPos === x - 1 && nodeYPos === y) ||\r\n          (nodeXPos === x && nodeYPos === y + 1) ||\r\n          (nodeXPos === x && nodeYPos === y - 1))\r\n      );\r\n    });\r\n  }\r\n\r\n  updateNeighbours(neighbours, currentNode) {\r\n    var distanceOfNeighbour = currentNode.getDistanceToStartNode() + 1;\r\n    for (let neighbour of neighbours) {\r\n      neighbour.setDistanceToStartNode(distanceOfNeighbour);\r\n      neighbour.setLastNode(currentNode);\r\n    }\r\n  }\r\n\r\n  sortByDistance(nodes) {\r\n    nodes.sort(\r\n      (a, b) => a.getDistanceToStartNode() - b.getDistanceToStartNode()\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathFinder;\r\n","import { NODEMODE } from \"../GridVisualization/NodeVisual\";\r\n\r\nconst DIRECTION_Y = 0;\r\nconst DIRECTION_X = 1;\r\n\r\n/**\r\n * Generate random number INCLUDING min and max excluding excepts\r\n * @param {Number} min\r\n * @param {Number} max\r\n * @param {Array} excepts\r\n */\r\nfunction generateRndNumber(min, max, excepts = []) {\r\n  if (excepts.length > max - min) {\r\n    // No more available numbers with given exceptions\r\n    throw new Error(\"No possible number with given excepts\");\r\n  }\r\n  var number = Math.floor(Math.random() * (max - min + 1) + min);\r\n  if (excepts.includes(number)) {\r\n    return generateRndNumber(min, max, excepts);\r\n  } else {\r\n    return number;\r\n  }\r\n}\r\n\r\n/**\r\n * Raw concept based on maze generation described in this blog:\r\n * http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm\r\n */\r\nclass MazeGenerator {\r\n  /**\r\n   * Function to call to start recursive maze generation\r\n   * @param {Array} grid\r\n   * @returns {Array} instructions to draw walls\r\n   */\r\n  generateMaze(grid) {\r\n    return this.doMazeGenerationStep(\r\n      grid,\r\n      DIRECTION_Y,\r\n      0,\r\n      0,\r\n      grid[0].length - 1,\r\n      grid.length - 1,\r\n      [],\r\n      []\r\n    );\r\n  }\r\n  /**\r\n   * Get relevant tiles to avoid for given square\r\n   * @param {Array} redZones\r\n   * @param {Number} xFrom\r\n   * @param {Number} yFrom\r\n   * @param {Number} xTo\r\n   * @param {Number} yTo\r\n   * @param {Number} wallDirection\r\n   * @returns {Array} Array of Numbers to avoid for Wall generation\r\n   */\r\n  getRelevantRedzones(redZones, xFrom, yFrom, xTo, yTo, wallDirection) {\r\n    let relevantRedzones = redZones.filter((redZone) => {\r\n      return (\r\n        redZone.y >= yFrom &&\r\n        redZone.y <= yTo &&\r\n        redZone.x >= xFrom &&\r\n        redZone.x <= xTo\r\n      );\r\n    });\r\n    relevantRedzones = relevantRedzones.map((redZone) =>\r\n      wallDirection === DIRECTION_X ? redZone.y : redZone.x\r\n    );\r\n    return [...new Set(relevantRedzones)];\r\n  }\r\n\r\n  /**\r\n   * Do recursive step to go down tree of maze\r\n   * @param {Array} grid\r\n   * @param {Number} wallDirection\r\n   * @param {Number} xFrom X-Coordinate of first tile in square\r\n   * @param {Number} yFrom Y-Coordinate of first tile in square\r\n   * @param {Number} xTo X-Coordinate of last tile in square\r\n   * @param {Number} yTo Y-Coordinate of last tile in squre\r\n   * @param {Array} instructions\r\n   * @param {Array} redZones Array of tiles to avoid to not clog maze\r\n   * @returns {Array} instructions for current level of tree\r\n   */\r\n  doMazeGenerationStep(\r\n    grid,\r\n    wallDirection,\r\n    xFrom,\r\n    yFrom,\r\n    xTo,\r\n    yTo,\r\n    instructions,\r\n    redZones\r\n  ) {\r\n    //Check if current square is large enough to draw wall\r\n    if (yTo - yFrom >= 2 && xTo - xFrom >= 2) {\r\n      var wallCoordinate;\r\n      var holePos;\r\n\r\n      if (wallDirection === DIRECTION_X) {\r\n        let excepts = this.getRelevantRedzones(\r\n          redZones,\r\n          xFrom,\r\n          yFrom + 1,\r\n          xTo,\r\n          yTo - 1,\r\n          wallDirection\r\n        );\r\n        try {\r\n          wallCoordinate = generateRndNumber(yFrom + 1, yTo - 1, excepts);\r\n        } catch {\r\n          // No wallcoordinate available with given exceptions -> bottom of tree reached\r\n          return instructions;\r\n        }\r\n        holePos = generateRndNumber(xFrom, xTo);\r\n        redZones.push({ x: holePos, y: wallCoordinate - 1 });\r\n        redZones.push({ x: holePos, y: wallCoordinate + 1 });\r\n      } else {\r\n        let excepts = this.getRelevantRedzones(\r\n          redZones,\r\n          xFrom + 1,\r\n          yFrom,\r\n          xTo - 1,\r\n          yTo,\r\n          wallDirection\r\n        );\r\n        try {\r\n          wallCoordinate = generateRndNumber(xFrom + 1, xTo - 1, excepts);\r\n        } catch {\r\n          // No wallcoordinate available with given exceptions -> bottom of tree reached\r\n          return instructions;\r\n        }\r\n        holePos = generateRndNumber(yFrom, yTo);\r\n        redZones.push({ x: wallCoordinate - 1, y: holePos });\r\n        redZones.push({ x: wallCoordinate + 1, y: holePos });\r\n      }\r\n\r\n      instructions.push({\r\n        wallDirection,\r\n        wallCoordinate,\r\n        holePos,\r\n        from: wallDirection === DIRECTION_Y ? yFrom : xFrom,\r\n        to: wallDirection === DIRECTION_Y ? yTo : xTo,\r\n      });\r\n      //Follow branch of child 1\r\n      instructions = this.doMazeGenerationStep(\r\n        grid,\r\n        wallDirection === DIRECTION_Y ? DIRECTION_X : DIRECTION_Y,\r\n        xFrom,\r\n        yFrom,\r\n        wallDirection === DIRECTION_Y ? wallCoordinate - 1 : xTo,\r\n        wallDirection === DIRECTION_X ? wallCoordinate - 1 : yTo,\r\n        instructions,\r\n        redZones\r\n      );\r\n      //Follow branch of child 2\r\n      instructions = this.doMazeGenerationStep(\r\n        grid,\r\n        wallDirection === DIRECTION_Y ? DIRECTION_X : DIRECTION_Y,\r\n        wallDirection === DIRECTION_Y ? wallCoordinate + 1 : xFrom,\r\n        wallDirection === DIRECTION_X ? wallCoordinate + 1 : yFrom,\r\n        xTo,\r\n        yTo,\r\n        instructions,\r\n        redZones\r\n      );\r\n    }\r\n    return instructions;\r\n    // Bottom of tree reached\r\n  }\r\n\r\n  /**\r\n   * Draw wall with given instructions\r\n   * @param {Array} grid\r\n   * @param {Number} wallDirection\r\n   * @param {Number} wallCoordinate\r\n   * @param {Number} holePos\r\n   * @param {Number} from First tile of wall (including)\r\n   * @param {Number} to  Last tile of wall (including)\r\n   */\r\n  drawWall(grid, wallDirection, wallCoordinate, holePos, from, to) {\r\n    var walls = [];\r\n    if (wallDirection === DIRECTION_X) {\r\n      // Draw wall in x direction accross piece to separate\r\n      for (let xPos = from; xPos <= to; xPos++) {\r\n        if (xPos !== holePos) {\r\n          grid[wallCoordinate][xPos].mode = NODEMODE.WALL;\r\n          walls.push(grid[wallCoordinate][xPos]);\r\n        }\r\n      }\r\n    } else {\r\n      // Draw wall in y direction accross piece to separate\r\n      for (let yPos = from; yPos <= to; yPos++) {\r\n        if (yPos !== holePos) {\r\n          grid[yPos][wallCoordinate].mode = NODEMODE.WALL;\r\n          walls.push(grid[yPos][wallCoordinate]);\r\n        }\r\n      }\r\n    }\r\n    return walls;\r\n  }\r\n}\r\n\r\nexport default MazeGenerator;\r\n","import React from \"react\";\nimport Grid from \"./pathfinding/GridVisualization/Grid\";\nimport PathFinder from \"./pathfinding/PathFinder/PathFinder\";\nimport MazeGenerator from \"./pathfinding/MazeGeneration/MazeGenerator\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <div className=\"navbar navbar-light bg-light\">\n          <span className=\"navbar-brand\">PathFinder</span>\n        </div>\n        <Grid\n          pathFinder={new PathFinder()}\n          mazeGenerator={new MazeGenerator()}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}